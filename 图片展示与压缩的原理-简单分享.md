# 图片展示与压缩的原理-简单分享



[TOC]

## 一、图片展示

图片格式有很多种 常见的有 GIF 、PNG、JPG、WEBP 像这种类型都是包含很多额外的信息 比如颜色索引表 反射表

但是如果我们从更底层出发去看 图片无非是一组数据

而计算机中，二进制是最通用的表示方式 那么最原始的图片就是一组二进制

现在我们使用node程序读取一张图片并且以json的形式展示出来

![demo](D:\work\CodeProject\fenxiang\images\demo.png)

![image-20210111005021878](D:\work\CodeProject\fenxiang\images\image-20210110231658728.png)

### 前置知识 

系统是如何识别图片格式的 ,并不一定是依靠文件的后缀 ,其实图片编码是具备一定的的规则的.像 *PNG* 的话就是头8位数是 **0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a** 表示图片的文件签名，如上图红色框框。

### 进一步分析

也就是说 浏览器其实是利用这些二进制 ，并且借助某些 “魔数” 来区分格式，采取不同的解码方式来解析图片 然后还原真正的二进制数据 从而显示到页面上

换言之，PNG并不能直接让计算机识别，而是以来程序进行解析才得以展示的，其他常见的图片格式也是如此

于是我们就可以知道为什么 IE 浏览器不支持WEBP，就是因为它并没有内置这种格式的解析逻辑

### 原始二进制 渲染原理

接下来，我将用一个例子来演示计算机是如何渲染一张图片的 

为了方便，我从网上下载了一个以前的游戏素材 （渲染图片\game.nes） 代码在 渲染图片 文件夹里

#### 第一步，用浏览器打开二进制文件

方式是利用ajax的方式

关于nes的一些信息与规则

- nes文件的图片是存在数据之中到处
- 每个图片是8*8像素的方块
- 每个像素2个bit

所以一个图块是占用16个bit

由于这里没有实现模拟器，没有办法执行它的汇编代码，所以图片的存储地址是不知道的，所以我们第一步应该寻找图片的存储地址

#### 寻找图片地址

用一个简单粗暴的方法 ，把所有的资源按上述规则显示出来 ，人肉去找到它

为了方便查找 一页显示8*8个图块 也就是canvas的宽高各64个像素，由于一个像素太小看不到，所以我们方法10倍展示 也就是640像素

于是我们可以看到从0到第64个方块如图

![image-20210111014141261](D:\work\CodeProject\fenxiang\images\image-20210111014141261.png)

经过人眼查看 发现当地址到达 32784的时候 图片是

![image-20210111022507112](D:\work\CodeProject\fenxiang\images\image-20210111022507112.png)

可以看出横的一排有8个8*8像素的方块

一个大的马里奥是由8个方块组成的

#### 像素拼接成一张图片

![image-20210111031345853](C:\Users\DaShao\AppData\Roaming\Typora\typora-user-images\image-20210111031345853.png)

## 二、图片压缩



